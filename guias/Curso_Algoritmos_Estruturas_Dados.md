# ğŸ§® Algoritmos e Estruturas de Dados: Master Class Edition
> **NÃ­vel:** Iniciante ao Ninja | **Foco:** LÃ³gica, Performance e EficiÃªncia
---

## ğŸ“– IntroduÃ§Ã£o: A Receita do Sucesso

Um **Algoritmo** nada mais Ã© do que uma receita. Se vocÃª quer fazer um bolo, precisa seguir passos logicamente ordenados. Na computaÃ§Ã£o, algoritmos sÃ£o os passos que o processador segue para resolver um problema. Sem algoritmos, o software nÃ£o sabe o que fazer. Sem **Estruturas de Dados**, o software nÃ£o sabe onde guardar os ingredientes.

---

## ğŸ—ï¸ MÃ³dulo 1: Complexidade de Algoritmos (O Tempo Ã© Dinheiro)

Um cÃ³digo que funciona em 1 segundo Ã© melhor que um que funciona em 1 hora. Para medir isso, usamos a **NotaÃ§Ã£o Big O**.

### ğŸ“ No seu Caderno (Anote!):
*   **O(1):** Tempo constante (Super rÃ¡pido, nÃ£o importa o tamanho do dado).
*   **O(n):** Tempo linear (Aumenta conforme a quantidade de dados aumenta).
*   **O(nÂ²):** Tempo quadrÃ¡tico (Cuidado! Fica muito lento com muitos dados).

---

## ğŸ“¦ MÃ³dulo 2: Estruturas de Dados DinÃ¢micas

Nem tudo cabe em uma lista simples. Ã€s vezes precisamos de estruturas mais inteligentes.

### 2.1 Pilhas (Stacks)
Pense em uma pilha de pratos. O Ãºltimo que vocÃª coloca Ã© o primeiro que vocÃª tira (**LIFO - Last In, First Out**).
*   *Exemplo:* O botÃ£o "Voltar" do seu navegador.

### 2.2 Filas (Queues)
Como uma fila de banco. O primeiro que chega Ã© o primeiro atendido (**FIFO - First In, First Out**).
*   *Exemplo:* A fila de documentos para a impressora.

---

## ğŸŒ³ MÃ³dulo 3: Ãrvores e Grafos (ConexÃµes Complexas)

Quando os dados nÃ£o sÃ£o lineares, usamos mapas.
*   **Ãrvores (Trees):** Como uma Ã¡rvore genealÃ³gica. Ãštil para pastas de arquivos ou menus de sites.
*   **Grafos (Graphs):** Como as conexÃµes do Facebook ou o GPS do Google Maps. Tudo estÃ¡ conectado a tudo.

---

## ğŸ” MÃ³dulo 4: Algoritmos de Busca e OrdenaÃ§Ã£o

Como o computador coloca nomes em ordem alfabÃ©tica?
1.  **Bubble Sort:** Compara dois a dois e vai "subindo" os maiores. (Lento!)
2.  **Quick Sort:** Divide o problema ao meio e resolve cada parte. (Muito rÃ¡pido!)
3.  **Busca BinÃ¡ria:** Em uma lista ordenada, vocÃª sempre olha o meio. Ã‰ como achar uma palavra no dicionÃ¡rio fÃ­sico.

---

## ğŸ“ ExercÃ­cios de FixaÃ§Ã£o (Para responder no caderno!)

1.  Explique com suas palavras a diferenÃ§a entre um algoritmo O(1) e um O(n).
2.  DÃª um exemplo do mundo real para uma estrutura de **Pilha (Stack)** que nÃ£o foi citado aqui.
3.  Em uma **Fila (Queue)**, qual elemento sai primeiro? O primeiro a entrar ou o Ãºltimo?
4.  O que Ã© um **NÃ³ (Node)** em uma estrutura de Ã¡rvore?
5.  A NotaÃ§Ã£o Big O mede apenas o tempo de execuÃ§Ã£o? Se nÃ£o, o que mais ela pode medir?
6.  Qual a vantagem da **Busca BinÃ¡ria** sobre uma busca comum (item por item)?
7.  Como funciona o algoritmo **Bubble Sort**?
8.  Desenhe no seu caderno uma Ã¡rvore simples com 3 nÃ­veis (Raiz, Pai e Filho).
9.  O que Ã© uma **Tabela Hash** e como ela ajuda na velocidade de busca?
10. **Desafio:** Se vocÃª tem uma lista de 1 milhÃ£o de nomes em ordem alfabÃ©tica, qual tÃ©cnica de busca vocÃª usaria para achar o nome "Matheus" o mais rÃ¡pido possÃ­vel?

---

### ğŸš€ PrÃ³ximos Passos
- [ğŸ§© POO na PrÃ¡tica](/guias/Curso_POO_Pratica) - Aprenda a organizar esses algoritmos em objetos.
- [ğŸ Python para AutomaÃ§Ã£o](/guias/Curso_Python_Automacao) - Coloque seus algoritmos para rodar.
